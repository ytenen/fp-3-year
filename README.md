# Почему **OCaml**

- **Строгая типизация.** Компилятор ловит целые классы ошибок ещё до запуска → меньше рантаймов и надёжнее код.
- **Алгебраические типы (ADT) и pattern matching.** Удобно описывать варианты и писать "ветки" как явные случаи вместо длинных `if/else`.
- **Быстрые нативные бинарники и мгновенный старт.** Для утилит и инструментов это ощутимо по сравнению с тяжёлыми рантаймами.
- **Строгие вычисления по умолчанию.** В Haskell ленивые вычисления по умолчанию усложняют прогнозирование производительности и профилирование, в OCaml поведение проще держать под контролем.

---

## Стек инструментов

- **opam** — зависимости и версии OCaml  
- **dune** — сборка/запуск/тесты  
- **ocamlformat** — автоформат кода  
- **QCheck / alcotest** — property-based и юнит-тесты

---

##ЛР-4: Статический анализатор Java кода

*Что хочу сделать*: систему статического анализа Java кода для автоматического поиска антипаттернов, ошибок и потенциальных уязвимостей. Анализатор включает:

- Парсер Java кода в абстрактное синтаксическое дерево (AST)
- Набор детекторов для выявления различных категорий проблем
- Систему композитных проверок, обнаруживающих сложные паттерны ошибок
- Генерацию детализированных отчётов с указанием местоположения проблем

Почему OCaml подходит: строгая система типов гарантирует корректность анализа AST, алгебраические типы точно описывают структуру Java программ, pattern matching упрощает реализацию детекторов антипаттернов, производительность нативного кода обеспечивает быстрый анализ больших проектов.



---

## Книга для изучения

- *Разработка программ с помощью Objective Caml* — Emmanuel Chailloux, Pascal Manoury, Bruno Pagano (18 мая 2007)

---

## Материалы для эссе и подготовки

- https://markkarpov.com/post/haskell-vs-ocaml  
- https://sanette.github.io/ocaml2.org/learn/description.html  
- https://habr.com/ru/articles/108529/  
- https://habr.com/ru/articles/152889/
