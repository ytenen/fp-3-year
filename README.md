# Почему **OCaml**

- **Строгая типизация с выводом типов.** Компилятор ловит целые классы ошибок ещё до запуска → меньше рантаймов и надёжнее код.
- **Алгебраические типы (ADT) и pattern matching.** Удобно описывать варианты и писать "ветки" как явные случаи вместо длинных `if/else`.
- **Быстрые нативные бинарники и мгновенный старт.** Для утилит и инструментов это ощутимый профит по сравнению с тяжёлыми рантаймами.
- **Строгие вычисления по умолчанию.** В Haskell ленивые вычисления по умолчанию усложняют прогнозирование производительности и профилирование; в OCaml поведение проще держать под контролем.

---

## Стек инструментов

- **opam** — зависимости и версии OCaml  
- **dune** — сборка/запуск/тесты  
- **ocamlformat** — автоформат кода  
- **QCheck / alcotest** — property-based и юнит-тесты

---

## ЛР-4: Мини-библиотека для Property-Based Testing

*Что хочу сделать*: собственную систему property-based testing — автоматической проверки свойств программ на множестве сгенерированных данных. Библиотека включает:

- Генераторы случайных значений для базовых типов и пользовательских данных
- Комбинаторы генераторов для построения сложных генераторов из простых
- Систему проверки свойств с автоматическим поиском минимального контрпримера

Почему OCaml подходит: строгая система типов гарантирует корректность генераторов, алгебраические типы описывают доменные объекты, pattern matching упрощает реализацию "упрощения" контрпримеров.

---

## Книга для изучения

- *Разработка программ с помощью Objective Caml* — Emmanuel Chailloux, Pascal Manoury, Bruno Pagano (18 мая 2007)

---

## Материалы для эссе и подготовки

- https://markkarpov.com/post/haskell-vs-ocaml  
- https://sanette.github.io/ocaml2.org/learn/description.html  
- https://habr.com/ru/articles/108529/  
- https://habr.com/ru/articles/152889/
